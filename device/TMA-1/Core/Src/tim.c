/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    tim.c
  * @brief   This file provides code for the configuration
  *          of the TIM instances.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "tim.h"

/* USER CODE BEGIN 0 */
extern uint32_t timer_flag;

#ifdef ENABLE_MONITOR_PULSE
extern uint32_t pulse_flag;
extern uint32_t pulse_value[PULSE_CH_COUNT];
extern uint32_t pulse_buffer_0[PULSE_CH_COUNT];
extern uint32_t pulse_buffer_1[PULSE_CH_COUNT];

static void CALC_PERIOD(int channel, uint32_t arr);
#endif

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
  static uint32_t count = 0;

  if (htim->Instance == TIM1) {
    count++;
    timer_flag |= 1 << FLAG_TIMER_100ms;

    if (count == 10) {
      count = 0;
      timer_flag |= 1 << FLAG_TIMER_1s;
    }
  }
}

#ifdef ENABLE_MONITOR_PULSE
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim) {
  uint32_t arr = htim->Instance->ARR;

  if (htim->Instance != TIM5) {
    return;
  }

  if ((pulse_flag & (1 << PULSE_ARMED)) == 0) {
    return;
  }

  switch (htim->Channel) {
    case HAL_TIM_ACTIVE_CHANNEL_1:
      if ((pulse_flag & (1 << PULSE_CH0_HALF)) == 0) {
        pulse_flag |= 1 << PULSE_CH0_HALF;
        HAL_TIM_IC_Start_DMA(&htim5, TIM_CHANNEL_1, (uint32_t *)&pulse_buffer_1[PULSE_CH0], 1);
      } else {
        CALC_PERIOD(PULSE_CH0, arr);
        pulse_flag &= ~(1 << PULSE_CH0_HALF);
        pulse_flag |= 1 << PULSE_CH0;
      }
      break;

    case HAL_TIM_ACTIVE_CHANNEL_2:
      if ((pulse_flag & (1 << PULSE_CH1_HALF)) == 0) {
        pulse_flag |= 1 << PULSE_CH1_HALF;
        HAL_TIM_IC_Start_DMA(&htim5, TIM_CHANNEL_1, (uint32_t *)&pulse_buffer_1[PULSE_CH1], 1);
      } else {
        CALC_PERIOD(PULSE_CH1, arr);
        pulse_flag &= ~(1 << PULSE_CH1_HALF);
        pulse_flag |= 1 << PULSE_CH1;
      }
      break;

    case HAL_TIM_ACTIVE_CHANNEL_3:
      if ((pulse_flag & (1 << PULSE_CH2_HALF)) == 0) {
        pulse_flag |= 1 << PULSE_CH2_HALF;
        HAL_TIM_IC_Start_DMA(&htim5, TIM_CHANNEL_1, (uint32_t *)&pulse_buffer_1[PULSE_CH2], 1);
      } else {
        CALC_PERIOD(PULSE_CH2, arr);
        pulse_flag &= ~(1 << PULSE_CH2_HALF);
        pulse_flag |= 1 << PULSE_CH2;
      }
      break;

    case HAL_TIM_ACTIVE_CHANNEL_4:
      if ((pulse_flag & (1 << PULSE_CH3_HALF)) == 0) {
        pulse_flag |= 1 << PULSE_CH3_HALF;
        HAL_TIM_IC_Start_DMA(&htim5, TIM_CHANNEL_1, (uint32_t *)&pulse_buffer_1[PULSE_CH3], 1);
      } else {
        CALC_PERIOD(PULSE_CH3, arr);
        pulse_flag &= ~(1 << PULSE_CH3_HALF);
        pulse_flag |= 1 << PULSE_CH3;
      }
      break;

    default:
      break;
  }

  if (pulse_flag == PULSE_READY) {
    pulse_flag |= (1 << PULSE_SET);
  }
}

int PULSE_SETUP(void) {
  // nothing to do
  return SYS_OK;
}

int PULSE_CAPTURE(void) {
  if ((pulse_flag & (1 << PULSE_ARMED)) == 0) {
    HAL_TIM_IC_Start_DMA(&htim5, TIM_CHANNEL_1, (uint32_t *)&pulse_buffer_0[PULSE_CH0], 1);
    HAL_TIM_IC_Start_DMA(&htim5, TIM_CHANNEL_2, (uint32_t *)&pulse_buffer_0[PULSE_CH1], 1);
    HAL_TIM_IC_Start_DMA(&htim5, TIM_CHANNEL_3, (uint32_t *)&pulse_buffer_0[PULSE_CH2], 1);
    HAL_TIM_IC_Start_DMA(&htim5, TIM_CHANNEL_4, (uint32_t *)&pulse_buffer_0[PULSE_CH3], 1);

    pulse_flag |= 1 << PULSE_ARMED;
    return SYS_OK;
  }

  return -1;
}

static inline void CALC_PERIOD(int channel, uint32_t arr) {
  pulse_value[channel] = pulse_buffer_1[channel] - pulse_buffer_0[channel];

  // reload calculation
  if (pulse_value[channel] < 0) {
    pulse_value[channel] += arr + 1;
  }
}
#endif
/* USER CODE END 0 */

TIM_HandleTypeDef htim1;
TIM_HandleTypeDef htim5;
DMA_HandleTypeDef hdma_tim5_ch1;
DMA_HandleTypeDef hdma_tim5_ch2;
DMA_HandleTypeDef hdma_tim5_ch3_up;
DMA_HandleTypeDef hdma_tim5_ch4_trig;

/* TIM1 init function */
void MX_TIM1_Init(void)
{

  /* USER CODE BEGIN TIM1_Init 0 */

  /* USER CODE END TIM1_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM1_Init 1 */

  /* USER CODE END TIM1_Init 1 */
  htim1.Instance = TIM1;
  htim1.Init.Prescaler = 840 - 1;
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim1.Init.Period = 20000 - 1;
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim1.Init.RepetitionCounter = 0;
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM1_Init 2 */

  /* USER CODE END TIM1_Init 2 */

}
/* TIM5 init function */
void MX_TIM5_Init(void)
{

  /* USER CODE BEGIN TIM5_Init 0 */

  /* USER CODE END TIM5_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_IC_InitTypeDef sConfigIC = {0};

  /* USER CODE BEGIN TIM5_Init 1 */

  /* USER CODE END TIM5_Init 1 */
  htim5.Instance = TIM5;
  htim5.Init.Prescaler = 84 - 1;
  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim5.Init.Period = 1000000 - 1;
  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim5) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_IC_Init(&htim5) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
  sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
  sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
  sConfigIC.ICFilter = 0;
  if (HAL_TIM_IC_ConfigChannel(&htim5, &sConfigIC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_IC_ConfigChannel(&htim5, &sConfigIC, TIM_CHANNEL_2) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_IC_ConfigChannel(&htim5, &sConfigIC, TIM_CHANNEL_3) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_IC_ConfigChannel(&htim5, &sConfigIC, TIM_CHANNEL_4) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM5_Init 2 */

  /* USER CODE END TIM5_Init 2 */

}

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(tim_baseHandle->Instance==TIM1)
  {
  /* USER CODE BEGIN TIM1_MspInit 0 */

  /* USER CODE END TIM1_MspInit 0 */
    /* TIM1 clock enable */
    __HAL_RCC_TIM1_CLK_ENABLE();

    /* TIM1 interrupt Init */
    HAL_NVIC_SetPriority(TIM1_UP_TIM10_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(TIM1_UP_TIM10_IRQn);
  /* USER CODE BEGIN TIM1_MspInit 1 */

  /* USER CODE END TIM1_MspInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM5)
  {
  /* USER CODE BEGIN TIM5_MspInit 0 */

  /* USER CODE END TIM5_MspInit 0 */
    /* TIM5 clock enable */
    __HAL_RCC_TIM5_CLK_ENABLE();

    __HAL_RCC_GPIOA_CLK_ENABLE();
    /**TIM5 GPIO Configuration
    PA0-WKUP     ------> TIM5_CH1
    PA1     ------> TIM5_CH2
    PA2     ------> TIM5_CH3
    PA3     ------> TIM5_CH4
    */
    GPIO_InitStruct.Pin = PIN0_Pin|PIN1_Pin|PIN2_Pin|PIN3_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* TIM5 DMA Init */
    /* TIM5_CH1 Init */
    hdma_tim5_ch1.Instance = DMA1_Stream2;
    hdma_tim5_ch1.Init.Channel = DMA_CHANNEL_6;
    hdma_tim5_ch1.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_tim5_ch1.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_tim5_ch1.Init.MemInc = DMA_MINC_ENABLE;
    hdma_tim5_ch1.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
    hdma_tim5_ch1.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
    hdma_tim5_ch1.Init.Mode = DMA_NORMAL;
    hdma_tim5_ch1.Init.Priority = DMA_PRIORITY_LOW;
    hdma_tim5_ch1.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_tim5_ch1) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(tim_baseHandle,hdma[TIM_DMA_ID_CC1],hdma_tim5_ch1);

    /* TIM5_CH2 Init */
    hdma_tim5_ch2.Instance = DMA1_Stream4;
    hdma_tim5_ch2.Init.Channel = DMA_CHANNEL_6;
    hdma_tim5_ch2.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_tim5_ch2.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_tim5_ch2.Init.MemInc = DMA_MINC_ENABLE;
    hdma_tim5_ch2.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
    hdma_tim5_ch2.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
    hdma_tim5_ch2.Init.Mode = DMA_NORMAL;
    hdma_tim5_ch2.Init.Priority = DMA_PRIORITY_LOW;
    hdma_tim5_ch2.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_tim5_ch2) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(tim_baseHandle,hdma[TIM_DMA_ID_CC2],hdma_tim5_ch2);

    /* TIM5_CH3_UP Init */
    hdma_tim5_ch3_up.Instance = DMA1_Stream0;
    hdma_tim5_ch3_up.Init.Channel = DMA_CHANNEL_6;
    hdma_tim5_ch3_up.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_tim5_ch3_up.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_tim5_ch3_up.Init.MemInc = DMA_MINC_ENABLE;
    hdma_tim5_ch3_up.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
    hdma_tim5_ch3_up.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
    hdma_tim5_ch3_up.Init.Mode = DMA_NORMAL;
    hdma_tim5_ch3_up.Init.Priority = DMA_PRIORITY_LOW;
    hdma_tim5_ch3_up.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_tim5_ch3_up) != HAL_OK)
    {
      Error_Handler();
    }

    /* Several peripheral DMA handle pointers point to the same DMA handle.
     Be aware that there is only one stream to perform all the requested DMAs. */
    __HAL_LINKDMA(tim_baseHandle,hdma[TIM_DMA_ID_CC3],hdma_tim5_ch3_up);
    __HAL_LINKDMA(tim_baseHandle,hdma[TIM_DMA_ID_UPDATE],hdma_tim5_ch3_up);

    /* TIM5_CH4_TRIG Init */
    hdma_tim5_ch4_trig.Instance = DMA1_Stream3;
    hdma_tim5_ch4_trig.Init.Channel = DMA_CHANNEL_6;
    hdma_tim5_ch4_trig.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_tim5_ch4_trig.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_tim5_ch4_trig.Init.MemInc = DMA_MINC_ENABLE;
    hdma_tim5_ch4_trig.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
    hdma_tim5_ch4_trig.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
    hdma_tim5_ch4_trig.Init.Mode = DMA_NORMAL;
    hdma_tim5_ch4_trig.Init.Priority = DMA_PRIORITY_LOW;
    hdma_tim5_ch4_trig.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_tim5_ch4_trig) != HAL_OK)
    {
      Error_Handler();
    }

    /* Several peripheral DMA handle pointers point to the same DMA handle.
     Be aware that there is only one stream to perform all the requested DMAs. */
    __HAL_LINKDMA(tim_baseHandle,hdma[TIM_DMA_ID_CC4],hdma_tim5_ch4_trig);
    __HAL_LINKDMA(tim_baseHandle,hdma[TIM_DMA_ID_TRIGGER],hdma_tim5_ch4_trig);

    /* TIM5 interrupt Init */
    HAL_NVIC_SetPriority(TIM5_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(TIM5_IRQn);
  /* USER CODE BEGIN TIM5_MspInit 1 */

  /* USER CODE END TIM5_MspInit 1 */
  }
}

void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef* tim_baseHandle)
{

  if(tim_baseHandle->Instance==TIM1)
  {
  /* USER CODE BEGIN TIM1_MspDeInit 0 */

  /* USER CODE END TIM1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_TIM1_CLK_DISABLE();

    /* TIM1 interrupt Deinit */
    HAL_NVIC_DisableIRQ(TIM1_UP_TIM10_IRQn);
  /* USER CODE BEGIN TIM1_MspDeInit 1 */

  /* USER CODE END TIM1_MspDeInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM5)
  {
  /* USER CODE BEGIN TIM5_MspDeInit 0 */

  /* USER CODE END TIM5_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_TIM5_CLK_DISABLE();

    /**TIM5 GPIO Configuration
    PA0-WKUP     ------> TIM5_CH1
    PA1     ------> TIM5_CH2
    PA2     ------> TIM5_CH3
    PA3     ------> TIM5_CH4
    */
    HAL_GPIO_DeInit(GPIOA, PIN0_Pin|PIN1_Pin|PIN2_Pin|PIN3_Pin);

    /* TIM5 DMA DeInit */
    HAL_DMA_DeInit(tim_baseHandle->hdma[TIM_DMA_ID_CC1]);
    HAL_DMA_DeInit(tim_baseHandle->hdma[TIM_DMA_ID_CC2]);
    HAL_DMA_DeInit(tim_baseHandle->hdma[TIM_DMA_ID_CC3]);
    HAL_DMA_DeInit(tim_baseHandle->hdma[TIM_DMA_ID_UPDATE]);
    HAL_DMA_DeInit(tim_baseHandle->hdma[TIM_DMA_ID_CC4]);
    HAL_DMA_DeInit(tim_baseHandle->hdma[TIM_DMA_ID_TRIGGER]);

    /* TIM5 interrupt Deinit */
    HAL_NVIC_DisableIRQ(TIM5_IRQn);
  /* USER CODE BEGIN TIM5_MspDeInit 1 */

  /* USER CODE END TIM5_MspDeInit 1 */
  }
}

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */
